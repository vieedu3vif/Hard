#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "driver/spi_master.h"
#include "soc/gpio_struct.h"
#include "driver/gpio.h"
#include <string.h>
#include "lora.h"
#include "max30102.h"
#include "mlx90614.h"
#include "esp_log.h"
#include <inttypes.h>  // Thêm thư viện để sử dụng PRIu32

#define NODE_ID "NODE_1"

// Định nghĩa cổng I2C
#define I2C_PORT I2C_NUM_0

// Tần số LoRa
#define LORA_FREQUENCY 433E6

// Thời gian đọc từ các cảm biến
#define MLX90614_READ_DURATION 10000 // 10 giây
#define MAX30102_READ_DURATION 20000 // 20 giây

static const char *TAG = "SENSOR_TASK";

void i2c_init() {
    int i2c_master_port = I2C_PORT;
    i2c_config_t conf;
    conf.mode = I2C_MODE_MASTER;
    conf.sda_io_num = 21;  // GPIO cho SDA
    conf.sda_pullup_en = GPIO_PULLUP_ENABLE;
    conf.scl_io_num = 22;  // GPIO cho SCL
    conf.scl_pullup_en = GPIO_PULLUP_ENABLE;
    conf.master.clk_speed = 100000;  // Tốc độ bus I2C (100kHz)
    i2c_param_config(i2c_master_port, &conf);
    i2c_driver_install(i2c_master_port, conf.mode, 0, 0, 0);
}

// Đo MLX90614 trong thời gian xác định mà không delay
void read_mlx90614_10s(float *temperature_c) {
    uint32_t start_time = xTaskGetTickCount();
    uint32_t current_time;

    if (mlx90614_init(I2C_PORT) != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize MLX90614");
        return;
    }

    ESP_LOGI(TAG, "MLX90614 initialized successfully");

    while ((current_time = xTaskGetTickCount()) - start_time < pdMS_TO_TICKS(MLX90614_READ_DURATION)) {
        if (mlx90614_read_temp_c(I2C_PORT, temperature_c) == ESP_OK) {
            ESP_LOGI(TAG, "Temperature (C): %.2f", *temperature_c);
        } else {
            ESP_LOGE(TAG, "Failed to read temperature in Celsius");
        }
    }
}

// Đo MAX30102 trong thời gian xác định mà không delay
void read_max30102_20s(float *heart_rate, float *spo2) {
    uint32_t start_time = xTaskGetTickCount();
    uint32_t current_time;
    uint32_t ir_data = 0;
    uint32_t red_data = 0;

    if (max30102_init(I2C_PORT) != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize MAX30102");
        return;
    }

    ESP_LOGI(TAG, "MAX30102 initialized successfully");

    while ((current_time = xTaskGetTickCount()) - start_time < pdMS_TO_TICKS(MAX30102_READ_DURATION)) {
        if (max30102_read_data(I2C_PORT, &ir_data, &red_data) == ESP_OK) {
        //    ESP_LOGI(TAG, "IR: %" PRIu32 ", RED: %" PRIu32, ir_data, red_data);

            *heart_rate = max30102_calculate_heart_rate(ir_data);
            *spo2 = max30102_calculate_spo2(ir_data, red_data);

            ESP_LOGI(TAG, "Heart Rate: %.2f bpm, SpO2: %.2f%%", *heart_rate, *spo2);
        } else {
            ESP_LOGE(TAG, "Failed to read data from MAX30102");
        }
    }
}

// Task truyền dữ liệu qua LoRa
void send_lora_data(float temperature, float heart_rate, float spo2) {
    char buf[100];
    
    int len = snprintf(buf, sizeof(buf), "ID: %s, Temp: %.2f, HR: %.2f, SpO2: %.2f", NODE_ID, temperature, heart_rate, spo2);

    lora_send_packet((uint8_t *)buf, len);
    ESP_LOGI(TAG, "Sent: %s", buf);
}


// Task chính
void sensor_task(void *pvParameters) {
    float temperature_c = 0;
    float heart_rate = 0;
    float spo2 = 0;

    // Khởi tạo LoRa
    lora_init();
    lora_set_frequency(LORA_FREQUENCY);
    lora_enable_crc();

    while (1) {
        // Đọc MLX90614 trong 10 giây
        read_mlx90614_10s(&temperature_c);

        // Đọc MAX30102 trong 20 giây
        read_max30102_20s(&heart_rate, &spo2);

        // Truyền dữ liệu qua LoRa
        send_lora_data(temperature_c, heart_rate, spo2);
    }
}

void app_main(void) {
    i2c_init();
    // Khởi động task đọc cảm biến và truyền LoRa
    xTaskCreate(sensor_task, "sensor_task", 4096, NULL, 5, NULL);
}

//////////

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "lora.h"
#include <stdio.h>

// Tần số LoRa
#define LORA_FREQUENCY 433E6

// Task nhận dữ liệu từ LoRa
void lora_receive_task(void *pvParameters) {
    uint8_t buf[256];
    int len;

    // Khởi tạo LoRa
    if (lora_init()) {
        printf("LoRa initialized successfully.\n");
    } else {
        printf("LoRa initialization failed.\n");
        vTaskDelete(NULL);  // Nếu khởi tạo thất bại, dừng task
        return;
    }

    // Cấu hình tần số và bật CRC
    lora_set_frequency(LORA_FREQUENCY);
    lora_enable_crc();

    while (1) {
        // Chuyển LoRa sang chế độ nhận
        lora_receive();

        // Kiểm tra xem có gói tin nào được nhận không
        if (lora_received()) {
            // Đọc gói tin đã nhận
            len = lora_receive_packet(buf, sizeof(buf));

            if (len > 0) {
                // Đảm bảo chuỗi nhận được là chuỗi ký tự có thể hiển thị
                buf[len] = '\0';  // Kết thúc chuỗi bằng ký tự null
                
                // In dữ liệu nhận được
                printf("Received data: %s\n", (char *)buf);

                // Hiển thị RSSI và SNR
                printf("RSSI: %d, SNR: %.2f\n", lora_packet_rssi(), lora_packet_snr());

                // Giả sử dữ liệu nhận được có dạng: "Temp: %.2f, HR: %.2f, SpO2: %.2f"
                float temperature, heart_rate, spo2;
                if (sscanf((char *)buf, "Temp: %f, HR: %f, SpO2: %f", &temperature, &heart_rate, &spo2) == 3) {
                    // In giá trị tách ra được
                    printf("Temperature: %.2f C, Heart Rate: %.2f bpm, SpO2: %.2f%%\n", temperature, heart_rate, spo2);
                } 
            }
        }

        // Chờ 1 giây trước khi tiếp tục kiểm tra gói tin mới
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}


void app_main(void) {
    // Khởi tạo task nhận dữ liệu từ LoRa
    xTaskCreate(lora_receive_task, "lora_receive_task", 4096, NULL, 5, NULL);
}

/////////
#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_wifi.h"
#include "nvs_flash.h"
#include "esp_event.h"
#include "esp_log.h"
#include "mqtt_client.h"
#include "esp_system.h"
#include "esp_netif.h"
#include "lora.h"

// Wi-Fi credentials
#define WIFI_SSID "Việt Anh"
#define WIFI_PASS "25051992"

// ThingsBoard credentials
#define MQTT_BROKER_URI "mqtt://demo.thingsboard.io:1883"
#define ACCESS_TOKEN "GCw2ijLxooFWzmNtebI5"


// LoRa frequency
#define LORA_FREQUENCY 433E6

// Log tag
static const char *TAG = "ThingsBoard";
esp_mqtt_client_handle_t client;

// Initialize Wi-Fi
void wifi_init() {
    esp_netif_init();
    esp_event_loop_create_default();
    esp_netif_create_default_wifi_sta();
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    esp_wifi_init(&cfg);
    esp_wifi_set_mode(WIFI_MODE_STA);
    
    wifi_config_t wifi_config = {
        .sta = {
            .ssid = WIFI_SSID,
            .password = WIFI_PASS
        }
    };
    
    esp_wifi_set_config(WIFI_IF_STA, &wifi_config);
    esp_wifi_start();
    esp_wifi_connect();
}

// MQTT event handler
static void mqtt_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) {
    if (event_id == MQTT_EVENT_CONNECTED) {
        ESP_LOGI(TAG, "Connected to ThingsBoard");
    } else if (event_id == MQTT_EVENT_DISCONNECTED) {
        ESP_LOGI(TAG, "Disconnected from ThingsBoard");
    }
}

// Initialize MQTT
void mqtt_init() {
    esp_mqtt_client_config_t mqtt_cfg = {
        .broker.address.uri = MQTT_BROKER_URI,
        .credentials.username = ACCESS_TOKEN
    };
    
    client = esp_mqtt_client_init(&mqtt_cfg);
    esp_mqtt_client_register_event(client, ESP_EVENT_ANY_ID, mqtt_event_handler, client);
    esp_mqtt_client_start(client);
}

// Send data to ThingsBoard
void send_data_to_thingsboard(const char *node_id, float temperature, float heart_rate, float spo2) {
    char payload[150];
    snprintf(payload, sizeof(payload), "{\"node_id\":\"%s\",\"temperature\":%.2f,\"heart_rate\":%.2f,\"spo2\":%.2f}", node_id, temperature, heart_rate, spo2);

    int msg_id = esp_mqtt_client_publish(client, "v1/devices/me/telemetry", payload, 0, 1, 0);
    if (msg_id != -1) {
        ESP_LOGI(TAG, "Data sent successfully, msg_id=%d, payload=%s", msg_id, payload);
    } else {
        ESP_LOGE(TAG, "Failed to send data");
    }
}

// LoRa receive task
void lora_receive_task(void *pvParameters) {
    uint8_t buf[256];
    int len;

    // Initialize LoRa
    if (lora_init()) {
        ESP_LOGI(TAG, "LoRa initialized successfully.");
    } else {
        ESP_LOGE(TAG, "LoRa initialization failed.");
        vTaskDelete(NULL);
        return;
    }

    lora_set_frequency(LORA_FREQUENCY);
    lora_enable_crc();

    while (1) {
        lora_receive();

        if (lora_received()) {
            len = lora_receive_packet(buf, sizeof(buf));
            if (len > 0) {
                buf[len] = '\0';
                ESP_LOGI(TAG, "Received data: %s", (char *)buf);
                ESP_LOGI(TAG, "RSSI: %d, SNR: %.2f", lora_packet_rssi(), lora_packet_snr());

                char node_id[50];
                float temperature, heart_rate, spo2;
                
                // Parse the LoRa data string with node ID
                if (sscanf((char *)buf, "ID: %49[^,], Temp: %f, HR: %f, SpO2: %f", node_id, &temperature, &heart_rate, &spo2) == 4) {
                    ESP_LOGI(TAG, "Parsed data - Node ID: %s, Temperature: %.2f C, Heart Rate: %.2f bpm, SpO2: %.2f%%", node_id, temperature, heart_rate, spo2);
                    
                    // Send parsed data to ThingsBoard
                    send_data_to_thingsboard(node_id, temperature, heart_rate, spo2);
                } else {
                    ESP_LOGE(TAG, "Data format mismatch: %s", (char *)buf);
                }
            }
        }

        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

void app_main(void) {
    nvs_flash_init();
    wifi_init();
    mqtt_init();

    xTaskCreate(lora_receive_task, "lora_receive_task", 4096, NULL, 5, NULL);
}